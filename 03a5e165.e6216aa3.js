(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{140:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return c})),n.d(t,"metadata",(function(){return i})),n.d(t,"rightToc",(function(){return s})),n.d(t,"default",(function(){return d}));var o=n(1),r=n(9),a=(n(0),n(184)),c={id:"event-loop",title:"The event loop",sidebar_label:"The event loop"},i={id:"node/advanced/event-loop",title:"The event loop",description:"## Concurrency and event loop",source:"@site/docs/node/advanced/event-loop.md",permalink:"/docs-and-blog/docs/node/advanced/event-loop",sidebar_label:"The event loop",sidebar:"someSidebar",previous:{title:"Streams",permalink:"/docs-and-blog/docs/node/advanced/streams"},next:{title:"Modularity",permalink:"/docs-and-blog/docs/node/advanced/modularity"}},s=[{value:"Concurrency and event loop",id:"concurrency-and-event-loop",children:[]},{value:"Asynchrony and synchrony",id:"asynchrony-and-synchrony",children:[]}],l={rightToc:s};function d(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(a.b)("wrapper",Object(o.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h2",{id:"concurrency-and-event-loop"},"Concurrency and event loop"),Object(a.b)("p",null,"The event loop. Slow i/o operations are handled by events and callbacks. i/o operations can be memory, disk, network or other processes. Disk and network resources are the most expensive operations. Node minimizes waiting time. Node does not use threads, it's single threaded."),Object(a.b)("p",null,"The event loop picks events from the event queue and pushes their callbacks to the call stack. It starts when a script is started and exited when no more callbacks or process.exit is called."),Object(a.b)("p",null,"V8 has a call stack and a heap. The heap is where objects are stored in memory. Both are part of the runtime engine not node itself. The loop is provided by the libuv."),Object(a.b)("p",null,"The call stack is a stack of functions. Only one stack. Only one function executed at a time. When executing a script every time we step into a function it is pushed into the stack and everytime we return from a function it gets popped out of the stack. It is printed on errors."),Object(a.b)("p",null,"Queue is a queue of events to be executed. When executing we move the callback to the stack. settimeout is provided by node and node executes a timer out of the runtime freeing the call stack to process more items. When the timer finishes node sends the callback to the event queue. Then the event loop will take events form the queue and add them to the stack when the stack is empty."),Object(a.b)("p",null,"When the timer delay is 0, it works in the same way as setImmediate. The callbacks will be executed after we are done with the stack. setImmediate can take precedende over settimeout with 0. process.nexttick is not part of the event loop, callbacks are processed after the current operation completes and before the event loop continues. process.nexttick can be used when returning a custom error in a async function asyncronussly."),Object(a.b)("h2",{id:"asynchrony-and-synchrony"},"Asynchrony and synchrony"),Object(a.b)("p",null,"JS is synchronous, one line at a time. Asynchrony in node allows other modules like libuv to process tasks from the event loop. When Node.js needs to perform an I/O operation instead of blocking the thread and wasting CPU cycles waiting, Node.js will resume the operations when the response comes back from libuv."))}d.isMDXComponent=!0},184:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return b}));var o=n(0),r=n.n(o);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function c(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?c(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):c(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=r.a.createContext({}),d=function(e){var t=r.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i({},t,{},e)),n},p=function(e){var t=d(e.components);return r.a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},h=Object(o.forwardRef)((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,c=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),p=d(n),h=o,b=p["".concat(c,".").concat(h)]||p[h]||u[h]||a;return n?r.a.createElement(b,i({ref:t},l,{components:n})):r.a.createElement(b,i({ref:t},l))}));function b(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,c=new Array(a);c[0]=h;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:o,c[1]=i;for(var l=2;l<a;l++)c[l]=n[l];return r.a.createElement.apply(null,c)}return r.a.createElement.apply(null,n)}h.displayName="MDXCreateElement"}}]);