(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{157:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return a})),n.d(t,"metadata",(function(){return l})),n.d(t,"rightToc",(function(){return s})),n.d(t,"default",(function(){return d}));var i=n(1),o=n(9),r=(n(0),n(190)),a={id:"modularDesign",title:"Modular design",author:"David Ortiz",author_url:"https://github.com/DavidOVM",author_image_url:"https://avatars2.githubusercontent.com/u/15112119?s=460&u=87d77526d3584da629e60e6cf8c5f65b0f9749c7&v=4",tags:["node","modularity"]},l={permalink:"/docs-and-blog/blog/modularDesign",source:"@site/blog/2020-05-05modularity.md",description:"Modular programming is a software design technique that emphasizes separating the functionality of a program into independent, interchangeable modules",date:"2020-05-05T00:00:00.000Z",tags:[{label:"node",permalink:"/docs-and-blog/blog/tags/node"},{label:"modularity",permalink:"/docs-and-blog/blog/tags/modularity"}],title:"Modular design",readingTime:1.73,truncated:!0,prevItem:{title:"Best practices in Node JS",permalink:"/docs-and-blog/blog/node-best-practices"},nextItem:{title:"Testing in Node",permalink:"/docs-and-blog/blog/testing"}},s=[{value:"Things to consider when designing a module",id:"things-to-consider-when-designing-a-module",children:[{value:"Comply with the single responsibility principle.",id:"comply-with-the-single-responsibility-principle",children:[]},{value:"API design",id:"api-design",children:[]},{value:"Encapsulation",id:"encapsulation",children:[]},{value:"Avoid mono-dependencies",id:"avoid-mono-dependencies",children:[]},{value:"Be aware of context",id:"be-aware-of-context",children:[]}]}],c={rightToc:s};function d(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(r.b)("wrapper",Object(i.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"Modular programming is a software design technique that emphasizes separating the functionality of a program into independent, interchangeable modules"),Object(r.b)("p",null,"Modularity helps with:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"migration"),Object(r.b)("li",{parentName:"ul"},"maintainability"),Object(r.b)("li",{parentName:"ul"},"future development"),Object(r.b)("li",{parentName:"ul"},"deployments"),Object(r.b)("li",{parentName:"ul"},"reusability"),Object(r.b)("li",{parentName:"ul"},"maximize productivity"),Object(r.b)("li",{parentName:"ul"},"testing\nWe should prevent code bases from growing organically.")),Object(r.b)("h2",{id:"things-to-consider-when-designing-a-module"},"Things to consider when designing a module"),Object(r.b)("p",null,"There are certain things we should take into account when deciding if a new feature should be a module or not."),Object(r.b)("h3",{id:"comply-with-the-single-responsibility-principle"},"Comply with the ",Object(r.b)("a",Object(i.a)({parentName:"h3"},{href:"https://en.wikipedia.org/wiki/Single_responsibility_principle"}),"single responsibility principle"),"."),Object(r.b)("p",null,"The single responsibility principle is a computer programming principle that states that every module or class should have responsibility over a single part of the functionality provided by the software, and that responsibility should be entirely encapsulated by the class, module or function."),Object(r.b)("p",null,"A module should be narrow and focused. It should have exclusive responsibility of a piece of the whole system. Every interaction with that piece should be handle by the module. "),Object(r.b)("h3",{id:"api-design"},"API design"),Object(r.b)("p",null,"A module should provide an interface for other modules or clients to interact with it. Pay special attencion to the design and definition of this interface (API). See ",Object(r.b)("a",Object(i.a)({parentName:"p"},{href:"https://nordicapis.com/the-three-principles-of-excellent-api-design/"}),"The Three Principles of Excellent API Design"),": Purpose, Usability and Constraints."),Object(r.b)("h3",{id:"encapsulation"},"Encapsulation"),Object(r.b)("p",null,"Limit the exposure of modules within their system. Only provide a controlled interface for access. The inner implementation should be changable withoutn interfiering with the clients. Control the dependencies between modules and minimize them to improve scalability. The network formed by the modules should be logical, easy to follow and simple."),Object(r.b)("h3",{id:"avoid-mono-dependencies"},"Avoid mono-dependencies"),Object(r.b)("p",null,"Submodules are a thing. If a module is only used by another module and won't be shared by any other modules maybe it should be part of its parent. Creating modules that have a 1-1 relation could generate mess in the system. Consider merging those modules or have one become a submodule."),Object(r.b)("h3",{id:"be-aware-of-context"},"Be aware of context"),Object(r.b)("p",null,"Be aware of your system context. Sometimes too many modules don't make sense for small systems. Modularization should be subjective and should not be pursued if it won't increase clarity."),Object(r.b)("p",null,Object(r.b)("a",Object(i.a)({parentName:"p"},{href:"https://medium.com/@shanebdavis/the-5-essential-elements-of-modular-software-design-6b333918e543"}),"5 essentials of modular design")))}d.isMDXComponent=!0},190:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return m}));var i=n(0),o=n.n(i);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,o=function(e,t){if(null==e)return{};var n,i,o={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=o.a.createContext({}),d=function(e){var t=o.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):l({},t,{},e)),n},u=function(e){var t=d(e.components);return o.a.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},b=Object(i.forwardRef)((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,a=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=d(n),b=i,m=u["".concat(a,".").concat(b)]||u[b]||p[b]||r;return n?o.a.createElement(m,l({ref:t},c,{components:n})):o.a.createElement(m,l({ref:t},c))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,a=new Array(r);a[0]=b;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,a[1]=l;for(var c=2;c<r;c++)a[c]=n[c];return o.a.createElement.apply(null,a)}return o.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"}}]);