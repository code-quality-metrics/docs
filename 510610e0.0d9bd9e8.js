(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{157:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return s})),n.d(t,"metadata",(function(){return i})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return p}));var r=n(1),a=n(9),o=(n(0),n(190)),s={id:"testing",title:"Testing in Node",author:"David Ortiz",author_url:"https://github.com/DavidOVM",author_image_url:"https://avatars2.githubusercontent.com/u/15112119?s=460&u=87d77526d3584da629e60e6cf8c5f65b0f9749c7&v=4",tags:["node","testing"]},i={permalink:"/docs-and-blog/blog/testing",source:"@site/blog/2020-03-25testing.md",description:"Recommendations and best practices for testing in Node (and general sw testing)",date:"2020-03-25T00:00:00.000Z",tags:[{label:"node",permalink:"/docs-and-blog/blog/tags/node"},{label:"testing",permalink:"/docs-and-blog/blog/tags/testing"}],title:"Testing in Node",readingTime:2.39,truncated:!0,prevItem:{title:"Modular design",permalink:"/docs-and-blog/blog/modularDesign"}},c=[],l={rightToc:c};function p(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(o.b)("wrapper",Object(r.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"Recommendations and best practices for testing in Node (and general sw testing)"),Object(o.b)("p",null,"For any type of test (unit, acceptance, integration...) and for any implementation or tool of said test, there are certain rules it should follow."),Object(o.b)("p",null,"Provide easy tracking of what is being tested. When naming a test make sure it includes what's being tested, under which circumstances and what's the expected behaviour. This will provide better understanding of what the test should do."),Object(o.b)("p",null,"When implementing the test, follow the Given - When - Then pattern. Preconditions, action and result. Set up the conditions for the test, default values, mocks and such. Then execute the action, should be just one. Finally, assert the results."),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-gherkin"}),"Feature: User model\n  Scenario: Create already created user\n    Given a user\n    When the same user is created\n    Then there is an error\n    And the user is not created twice\n")),Object(o.b)("pre",null,Object(o.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"// Keep tests independent\nbeforeEach(done => {\n  User.collection.drop(() => done())\n})\n// descriptive names\ndescribe('User model', function() {\n  it('Should not create user when when already created', ()=> {\n    // Given\n    // mimic real values (name)\n    const user1 = new User({name: 'Mike'})\n    // When\n    const user2 = new User({name: 'Mike'})\n    // Then\n    expect(user2).toBeNull()\n  })\n})\n\n/**\n * User model - Should create user when valid name\n * User model - Should not create user when invalid name\n * User model - Should not create user when already created\n * ...\n * /\n")),Object(o.b)("p",null,"Keep language easy and understandable by non-engineering profiles (even more important for acceptance tests). For this try to keep the code clean. If testing an error, don't add try catch, use something like ",Object(o.b)("inlineCode",{parentName:"p"},"expect(method).to.throw")," to make it easier to read."),Object(o.b)("p",null,"It's also important to define what needs to be tested. Sometimes it's better to start from the outside and test the system as a blackbox and then go deeper into the implementation."),Object(o.b)("p",null,"Any test should mimic the real execution as much as possible. That's why when testing features that use external services it's better to stub or spy than to mock. Spies are clearer and closer to the real behaviour of the system. Also when providing values for tests try to keep them as close to reality as possible (e.g. real names, addresses etc)."),Object(o.b)("p",null,"Tests should be independent (as much as possible). Don't seed the db globaly before testing. Drop everything from there and have each test add whatever is necessary for it."),Object(o.b)("p",null,Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://www.npmjs.com/package/sinon"}),"https://www.npmjs.com/package/sinon"),"\n",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://www.npmjs.com/package/node-mocks-http"}),"https://www.npmjs.com/package/node-mocks-http"),"\n",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://github.com/goldbergyoni/node-chaos-monkey"}),"https://github.com/goldbergyoni/node-chaos-monkey")),Object(o.b)("p",null,"Aim for a 80% test coverage. Anything over that could be too expensive and won't provide more confidence."),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"I would be suspicious of anything like 100% - it would smell of someone writing tests to make the coverage numbers happy, but not thinking about what they are doing.\n",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://martinfowler.com/bliki/TestCoverage.html"}),"https://martinfowler.com/bliki/TestCoverage.html"))),Object(o.b)("p",null,"Don't forget linting. This could prevent many errors and it's fast to implement and run. Should be the first step."),Object(o.b)("p",null,Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://github.com/goldbergyoni/javascript-testing-best-practices"}),"https://github.com/goldbergyoni/javascript-testing-best-practices")))}p.isMDXComponent=!0},190:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return h}));var r=n(0),a=n.n(r);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=a.a.createContext({}),p=function(e){var t=a.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i({},t,{},e)),n},u=function(e){var t=p(e.components);return a.a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},b=Object(r.forwardRef)((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),u=p(n),b=r,h=u["".concat(s,".").concat(b)]||u[b]||d[b]||o;return n?a.a.createElement(h,i({ref:t},l,{components:n})):a.a.createElement(h,i({ref:t},l))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,s=new Array(o);s[0]=b;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var l=2;l<o;l++)s[l]=n[l];return a.a.createElement.apply(null,s)}return a.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"}}]);