(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{143:function(e,t,r){"use strict";r.r(t),r.d(t,"frontMatter",(function(){return s})),r.d(t,"metadata",(function(){return c})),r.d(t,"rightToc",(function(){return l})),r.d(t,"default",(function(){return p}));var a=r(1),n=r(9),o=(r(0),r(190)),s={id:"passwords",title:"Passwords",sidebar_label:"Passwords"},c={id:"node/cryptography/passwords",title:"Passwords",description:"Passwords are susceptible to:",source:"@site/docs/node/cryptography/passwords.md",permalink:"/docs-and-blog/docs/node/cryptography/passwords",sidebar_label:"Passwords",sidebar:"someSidebar",previous:{title:"The crypto module",permalink:"/docs-and-blog/docs/node/cryptography/crypto"},next:{title:"Data at rest",permalink:"/docs-and-blog/docs/node/cryptography/data-at-rest"}},l=[{value:"Good algorithms",id:"good-algorithms",children:[]},{value:"Salt",id:"salt",children:[]}],i={rightToc:l};function p(e){var t=e.components,r=Object(n.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},i,r,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"Passwords are susceptible to:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Dictionary atacks, people choose poor passwords with common words."),Object(o.b)("li",{parentName:"ul"},"Credential stuffing, caused by using the same password in multiple websites."),Object(o.b)("li",{parentName:"ul"},"Data breaches, they make passwords public.")),Object(o.b)("p",null,"Hashing is the best way to protect passwords. Hashes are randomized, one way functions. Not all hash algorithms are secure, for example MD5 is now weak and should not be used for passwords. MD5 has a small output and does is not well protected against collisions."),Object(o.b)("p",null,"The crypto module has a createHash function that accepts the hashing algorithm, then with the update method we provide the password and finally calling digest will compute the hash. digest and update can only be called once per instance of the hash."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const crypto = require('crypto')\nconst hash = crypto.createHash('md5')\nhash.update('pass')\nconst hashedPassword = hash.digest('hex')\n")),Object(o.b)("p",null,"A rainbow table is a db with all possible hash values to common strings."),Object(o.b)("p",null,"sha(256) is longer and better protected but the rainbow table is still a problem."),Object(o.b)("h3",{id:"good-algorithms"},"Good algorithms"),Object(o.b)("p",null,"From best to worst"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"Argon2, (academically) new and not well integrated in node yet"),Object(o.b)("li",{parentName:"ul"},"PBKDF2, good for enterprices"),Object(o.b)("li",{parentName:"ul"},"scrypt"),Object(o.b)("li",{parentName:"ul"},"bcrypt based on blowfish")),Object(o.b)("h3",{id:"salt"},"Salt"),Object(o.b)("p",null,"Salt is a random value added to the hash computation. Every hash need a different salt. Same passwords will have different hashes and thus, removing the rainbow table problem."),Object(o.b)("p",null,"Salts can be generated with randomBytes, that returns a random buffer. Then we can use pbkdf2Sync (or async) to generate a hash with PBKDF2. Third parameter is the number of iterations. The returned hash is returned as a buffer."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-js"}),"const crypto = require('crypto')\nconst password = 'pass'\nconst salt = crypto.randomBytes(256).toString('hex')\nconst hashedPassword = crypto.pbkdf2Sync(password, salt, 100000, 512, 'sha512')\n")),Object(o.b)("p",null,"Always store passwords hashed with a salt."))}p.isMDXComponent=!0},190:function(e,t,r){"use strict";r.d(t,"a",(function(){return d})),r.d(t,"b",(function(){return h}));var a=r(0),n=r.n(a);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function s(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function c(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?s(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):s(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},o=Object.keys(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var i=n.a.createContext({}),p=function(e){var t=n.a.useContext(i),r=t;return e&&(r="function"==typeof e?e(t):c({},t,{},e)),r},d=function(e){var t=p(e.components);return n.a.createElement(i.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.a.createElement(n.a.Fragment,{},t)}},b=Object(a.forwardRef)((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,i=l(e,["components","mdxType","originalType","parentName"]),d=p(r),b=a,h=d["".concat(s,".").concat(b)]||d[b]||u[b]||o;return r?n.a.createElement(h,c({ref:t},i,{components:r})):n.a.createElement(h,c({ref:t},i))}));function h(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,s=new Array(o);s[0]=b;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c.mdxType="string"==typeof e?e:a,s[1]=c;for(var i=2;i<o;i++)s[i]=r[i];return n.a.createElement.apply(null,s)}return n.a.createElement.apply(null,r)}b.displayName="MDXCreateElement"}}]);